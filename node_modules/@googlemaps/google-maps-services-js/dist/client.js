"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const index_1 = require("./index");
const agentkeepalive_1 = require("agentkeepalive");
const directions_1 = require("./directions");
const distance_1 = require("./distance");
const elevation_1 = require("./elevation");
const geolocate_1 = require("./geolocate");
const timezone_1 = require("./timezone");
const geocode_1 = require("./geocode/geocode");
const reversegeocode_1 = require("./geocode/reversegeocode");
const autocomplete_1 = require("./places/autocomplete");
const details_1 = require("./places/details");
const findplacefromtext_1 = require("./places/findplacefromtext");
const photo_1 = require("./places/photo");
const placesnearby_1 = require("./places/placesnearby");
const queryautocomplete_1 = require("./places/queryautocomplete");
const textsearch_1 = require("./places/textsearch");
const nearestroads_1 = require("./roads/nearestroads");
const snaptoroads_1 = require("./roads/snaptoroads");
exports.defaultHttpsAgent = new agentkeepalive_1.HttpsAgent({ keepAlive: true });
exports.defaultTimeout = 10000;
exports.userAgent = `google-maps-services-node-${index_1.version}`;
exports.acceptEncoding = "gzip";
exports.X_GOOG_MAPS_EXPERIENCE_ID = "X-GOOG-MAPS-EXPERIENCE-ID";
const defaultConfig = {
    timeout: exports.defaultTimeout,
    httpsAgent: exports.defaultHttpsAgent,
    headers: {
        "User-Agent": exports.userAgent,
        "Accept-Encoding": exports.acceptEncoding
    }
};
exports.defaultAxiosInstance = axios_1.default.create(defaultConfig);
class Client {
    constructor({ axiosInstance, config, experienceId } = {}) {
        if (axiosInstance && config) {
            throw new Error("Provide one of axiosInstance or config.");
        }
        if (axiosInstance) {
            this.axiosInstance = axiosInstance;
            this.axiosInstance.defaults.headers = Object.assign(Object.assign({}, defaultConfig.headers), this.axiosInstance.defaults.headers);
        }
        else if (config) {
            config = Object.assign(Object.assign({}, defaultConfig), config);
            config.headers = Object.assign(Object.assign({}, defaultConfig.headers), (config.headers || {}));
            this.axiosInstance = axios_1.default.create(config);
        }
        else {
            this.axiosInstance = exports.defaultAxiosInstance;
        }
        if (experienceId) {
            this.setExperienceId(...experienceId);
        }
    }
    setExperienceId(...ids) {
        this.experienceId = ids;
        this.axiosInstance.defaults.headers[exports.X_GOOG_MAPS_EXPERIENCE_ID] = ids.join(",");
    }
    clearExperienceId() {
        this.experienceId = null;
        this.clearExperienceIdHeader();
    }
    clearExperienceIdHeader() {
        delete this.axiosInstance.defaults.headers[exports.X_GOOG_MAPS_EXPERIENCE_ID];
    }
    getExperienceId() {
        return this.experienceId;
    }
    directions(request) {
        return directions_1.directions(request, this.axiosInstance);
    }
    distancematrix(request) {
        return distance_1.distancematrix(request, this.axiosInstance);
    }
    elevation(request) {
        return elevation_1.elevation(request, this.axiosInstance);
    }
    timezone(request) {
        return timezone_1.timezone(request, this.axiosInstance);
    }
    geolocate(request) {
        return geolocate_1.geolocate(request, this.axiosInstance);
    }
    geocode(request) {
        return geocode_1.geocode(request, this.axiosInstance);
    }
    reverseGeocode(request) {
        return reversegeocode_1.reverseGeocode(request, this.axiosInstance);
    }
    placeAutocomplete(request) {
        return autocomplete_1.placeAutocomplete(request, this.axiosInstance);
    }
    placeDetails(request) {
        return details_1.placeDetails(request, this.axiosInstance);
    }
    findPlaceFromText(request) {
        return findplacefromtext_1.findPlaceFromText(request, this.axiosInstance);
    }
    placePhoto(request) {
        return photo_1.placePhoto(request, this.axiosInstance);
    }
    placesNearby(request) {
        return placesnearby_1.placesNearby(request, this.axiosInstance);
    }
    placeQueryAutocomplete(request) {
        return queryautocomplete_1.placeQueryAutocomplete(request, this.axiosInstance);
    }
    textSearch(request) {
        return textsearch_1.textSearch(request, this.axiosInstance);
    }
    nearestRoads(request) {
        return nearestroads_1.nearestRoads(request, this.axiosInstance);
    }
    snapToRoads(request) {
        return snaptoroads_1.snapToRoads(request, this.axiosInstance);
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map